


{ Рабочий Проект :RGZ (Сетевая задача ' Задача о максимальном потоке') 
  Группа: 5ПМ-1  Преподаватель : Зверева Т.В.(кафедра ПМиИ)
  Авторы проекта Студенты: Cвириденко О.В., Родионова Е.А.   }


{  "Задача о максимальном потоке"
Дано: Cеть , имеющая только один источник s и только один сток t. 
Предположим , что интенсивность источника неизвестна . Обозначим ее через v. Тогда 
                                    | V, i=s
          Sum(j)x[i,j]-Sum(j)x[j,i]=|-v, i=t  
                                    | 0, i<>s,t
                здесь 0<=x[i,j]<=r[i,j].
r[i,j]>0 -пропускная способность дуги
x[i,j]- величина потока по дуге (i,j)

Алгоритм решения задачи : 

            Метод расстановки пометок (Метод Форда-Фалкерсона).

  Решение начинается с произвольного потока x[i,j] величины v (например, нулевого). 
Пометка произвольной вершины i состоит из двух чисел:N[i],Q[i]. Это значит , что от 
источника к вершине i может быть доставлено дополнительно единиц Q[i] потока по 
некоторой цепи , последним ребром которой является ребро (|N[i]|,i). Переходя затем
к вершине |N[i]|, можно будет на основе пометки этой вершины определить предыдущее 
ребро и т.д. до тех пор , пока не будет найдено начальное ребро , концом которого 
является источник .
 Опишем этот процесс более подробно. Предположим , что после k итераций был получен
поток x[i,j] величины v. Тогда (k+1)-ая итерация заключается в следующем. 
  ШАГ 1. Пометим вершину s числами N[s]=0,Q[s]=MaxNumber(real or integer).
Далее расстановку пометок продолжаем итеративно. Рассмотрим одну из помеченных вершин
, например i. Числами N[j]=-i, Q[j]=min(Q[i],x[j,i]) пометим все непомеченные вершины j,
для которых x[j,i]>0, и числами N[j]=i, Q[j]=min(Q[j],r[i,j]-x[i,j]),- для которых
r[i,j]-x[i,j]>0.  Затем рассмотрим следующую помеченную вершину и поступим аналогично.
Продолжаем расставлять пометки до тех пор , пока не дойдем до вершины t или пока нельзя
будет сделать дальнейших пометок .
 В первом случае перейдем к шагу 2 , т.е. построению потока, величина которого больше, 
во втором случае исходный поток будет максимальный. Заметим , что количество сделанных 
пометок может увеличиваться только в том случае , если рассматривать различные помеченные
 вершины , т.е. после того , как одна из помеченных вершин рассмотрена , вторично ее 
рассматривать не надо .
   ШАГ 2. Пусть  N[t],Q[t]- пометка вершины t. Величину исходного потока можно увеличить
 на Q[t] следующим образом. Если N[t]>0, то прибавим Q[t] к x[i1,t], i1=|N[t]| , а если N[t]<0,
 то вычтем Q[t] из x[t,i1]. Перейдем к вершине i1. Если N[i1]>0, то прибавим Q[t] к x[i2,i1],
 i2=|N[i2]|, а если N[i2]<0 , то вычтем Q[t] из x[i1,i2]. Перейдем к вершине i2 и т.д.
 до тех пор, пока не достигнем источника s. После этого изменение исходного потока
 прекращается , стираются все пометки и вновь переходим к шагу 1.

Теорема: Если функция пропускной способности r[i,j] целочисленна,
 то существует максимальный поток, который является также целочисленным. }

{Литература : Форд Л.,Фалкерсон Д. Потоки в сетях . "Мир",М.,1966. }

{Текст программы. TurboPascal v. 7.0.--------------------------------------}

Program NetWorkMax(input,output);
Uses Crt,Dos;
const
      n=12;  {число узлов(вершин)}
nameR='matmod.prn'; {Формирование матрицы(пропускных способностей)r[i,j] из файла}
nameOut='RGZmod.prn'; {Выходной файл рассчитанных данных=Оптимальный поток x[i,j]}

Var
  R,X:array[1..n,1..n] of real;  {весовая матрица и потока}
  nN,Spot:array[1..n] of integer; {матрица индексов}
  nQ:array[1..n] of real;
  maxV:real; {Поток}
  i,j,k,l,p,fl,fl1,Step:integer;
  rf:text; {Указатель на файл}

{Функция минимума}
function minStream(a,b:real):real;
begin  if(a<=b)then minStream:=a else minStream:=b; end;

begin {Основной блок}

ClrScr; Writeln('"файл"-Исходная матрица->Процесс->"файл"-результаты');
Writeln(' Press any key for run.');repeat until KeyPressed;Writeln('Идет расчет..');

{$I-} Assign(rf,nameR);Reset(rf);{$I+} {Формирование матрицы r[i,j] из файла}
if(IOResult<>0) then
begin Writeln('Cannot find or read datafile=',nameR); exit; end;
 for i:=1 to n do for j:=1 to n do Read(rf,R[i,j]); Close(rf); i:=IOResult;

{$I-} Assign(rf,nameOut);Rewrite(rf);{$I+}
if(IOResult<>0) then
begin Writeln('Cannot creat out file=',nameOut); exit; end;i:=IOResult;

 maxV:=0;for i:=1 to n do for j:=1 to n do X[i,j]:=0; {Начальный поток}
fl:=0;{флажок для завершения решения}
Step:=0;{Подсчет числа итераций необходимых для решения}
repeat
  {Шаг 1.Стирание пометок}
  for i:=1 to n do begin nN[i]:=0;nQ[i]:=0;Spot[i]:=0;end;
  {Шаг 2.Расстановка пометок}
  {Начальные условия}
  i:=1; nN[i]:=0; nQ[i]:=1e10; {very large number}
  Spot[i]:=1;{Пометка вершины для просмотра}
  l:=1;{счетчик помеченных и просмотренных вершин}
  k:=1;{счетчик помеченных вершин}
  p:=i;{максимальный номер помеченных(просмотренных) вершин}
fl1:=0;{флажок для завершения процесса расстановки пометок}
repeat
 for j:=1 to n do
  if(nN[j]=0)then
   if(R[i,j]<>0)then
  begin
  if(X[j,i]>0) then
    begin nN[j]:=-i;nQ[j]:=minStream(nQ[i],X[j,i]);
	  k:=k+1; if (j>p) then p:=j;    end;
  if(nN[j]=0)then
   if((R[i,j]-X[i,j])>0) then
    begin nN[j]:=i;nQ[j]:=minStream(nQ[i],R[i,j]-X[i,j]);
          k:=k+1; if (j>p) then p:=j;    end;
  end;
 {Проверка - дошли ли до вершины t}
 if(nN[n]<>0) then fl1:=1
  else 
   if(k=l) then begin fl1:=1;fl:=1; end {Нельзя сделать дальнейших пометок}
    else
    begin {Выбор помеченной вершины для просмотра случ. образом}
     Randomize;
     repeat i:=Random(p)+1;until ((Spot[i]=0) and (nN[i]<>0));
     Spot[i]:=1;l:=l+1;
   end;
until(fl1=1);
 if(fl=0)then 
 {Шаг 3.Увеличение исходного потока}
  begin i:=n;maxV:=maxV+nQ[n];
   repeat
    if(nN[i]>0) then X[Abs(nN[i]),i]:=X[Abs(nN[i]),i]+nQ[n]; 
    if(nN[i]<0) then X[i,Abs(nN[i])]:=X[i,Abs(nN[i])]-nQ[n]; 
    i:=nN[i];
   until(i=1);
  end;
Step:=Step+1;
until(fl=1);

{ Вывод результатов }
 Writeln(rf,' Number iter(ЧислоИтераций)=',Step,'  maxПоток{V}=',maxV:2:2);
 for i:=1 to n do
   begin Writeln(rf,' '); for j:=1 to n do Write(rf,' ',X[i,j]:2:2);end;

 Close(rf);ClrScr;
 GotoXY(10,12);Writeln(' File created .Press any key for exit.');
 GotoXY(10,14);Writeln(' Number iter(ЧислоИтераций)=',Step,'  maxПоток{V}=',maxV:2:2);
 repeat until KeyPressed;

end.

{Группа: 5ПМ-1  Преподаватель : Зверева Т.В.(кафедра ПМиИ)
 Авторы проекта Студенты: Cвириденко О.В., Родионова Е.А.
 Год 2000}

